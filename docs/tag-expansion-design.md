# Tag Expansion — Design Document

**Status:** Implemented
**Date:** February 2026

---

## Summary

Tags are non-terminals in the varp manifest grammar. Wherever the system accepts component names, it also accepts tags — expanding them to the set of components carrying that tag. This makes tags a first-class grouping primitive across the entire API surface.

## The Grammar

The manifest defines a simple language:

- **Terminals**: component names (`shared`, `manifest`, `cli`)
- **Non-terminals**: tags (`core`, `plugin`, `audit`)
- **Production rule**: a tag expands to all components carrying that tag

Resolution precedence: component name (exact match) > tag > error. This prevents ambiguity when a component and tag share a name.

## Two Expansion Layers

### 1. Parse-time: `resolveDeps` in `packages/varp/src/manifest/parser.ts`

`deps` entries expand when the manifest is parsed. Downstream code (graph traversal, lint, imports, render) only sees resolved component names. Self-exclusion applies: a component tagged `core` with `deps: [core]` does not depend on itself.

```yaml
cli:
  path: ./packages/varp/src/cli/src
  deps: [core] # expands to all core-tagged components
```

### 2. API-boundary: `resolveComponentRefs` in `packages/varp/src/shared/ownership.ts`

MCP tool parameters that accept component name arrays expand tags before delegating to core functions. No self-exclusion (no "self" concept at the API boundary).

**Affected tools:**

| Tool                        | Parameters        |
| --------------------------- | ----------------- |
| `varp_resolve_docs`         | `reads`, `writes` |
| `varp_invalidation_cascade` | `changed`         |
| `varp_ack_freshness`        | `components`      |
| `varp_verify_capabilities`  | `reads`, `writes` |
| `varp_check_env`            | `components`      |
| `varp_check_warm_staleness` | `components`      |

### Where expansion does NOT apply

Scheduler tools (`varp_compute_waves`, `varp_detect_hazards`, `varp_critical_path`, `varp_derive_restart_strategy`) accept `TaskDefinitionSchema` with `touches.reads`/`touches.writes`. These come from parsed plan XML and use resolved component names. Plans are generated by the planner skill which has full manifest context — no expansion needed.

## Design Principle

Expansion happens at the system boundary (manifest parse, MCP handler). Core functions only operate on terminals. This keeps the core logic simple and testable — one expansion utility, many call sites, zero changes to downstream algorithms.
