# Kiste Implementation Plan (Phase 0 + 1)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task. Use effect-ts skills (effect-core, schema, requirements-management, platform, testing, error-management, code-style) when writing Effect code.

**Goal:** Build `packages/kiste/` — a git-backed artifact index with SQLite read model and MCP query interface, using Effect TS.

**Architecture:** Git history is the event store. A TypeScript/Bun indexer reads commits via `@effect/platform` Command, extracts metadata + tags, writes to SQLite via `@effect/sql-sqlite-bun`. An MCP server exposes read-only query tools. Content is never stored in SQLite — read from git on demand. Three Effect services (Config, Git, Db) composed via layers.

**Tech Stack:** Effect TS (`effect`, `@effect/platform`, `@effect/platform-bun`, `@effect/sql`, `@effect/sql-sqlite-bun`, `@effect/schema`, `@effect/cli`), MCP SDK (`@modelcontextprotocol/sdk`, `zod`), Bun runtime, bun:test.

**Design doc:** `packages/kiste/design.md` (was `packages/artifact-store/design.md`)

---

## Task 1: Package Scaffold

**Files:**
- Rename: `packages/artifact-store/` → `packages/kiste/`
- Create: `packages/kiste/package.json`
- Create: `packages/kiste/tsconfig.json`
- Create: `packages/kiste/src/index.ts` (placeholder)

**Step 1: Rename the directory**

```bash
mv packages/artifact-store packages/kiste
```

**Step 2: Create package.json**

```json
{
  "name": "@varp/kiste",
  "version": "0.1.0",
  "type": "module",
  "bin": {
    "kiste": "./dist/cli.js"
  },
  "scripts": {
    "build": "bun build ./src/Cli.ts ./src/Mcp.ts --outdir ./dist --target bun",
    "test": "bun test --concurrent",
    "lint": "oxlint --type-aware",
    "format": "oxfmt --write 'src/**/*.ts'",
    "format:check": "oxfmt --check 'src/**/*.ts'",
    "check": "bun run format:check && bun run lint && bun run build",
    "typecheck": "oxlint --type-aware --type-check",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "effect": "^3.19.0",
    "@effect/platform": "^0.77.0",
    "@effect/platform-bun": "^0.55.0",
    "@effect/sql": "^0.30.0",
    "@effect/sql-sqlite-bun": "^0.23.0",
    "@effect/schema": "^0.99.0",
    "@effect/cli": "^0.56.0",
    "@modelcontextprotocol/sdk": "^1.9.0",
    "zod": "^3.24.0"
  },
  "devDependencies": {}
}
```

Note: Check exact latest versions of Effect packages with `bun add` — the versions above are approximate. Use `bun add effect @effect/platform @effect/platform-bun @effect/sql @effect/sql-sqlite-bun @effect/schema @effect/cli @modelcontextprotocol/sdk zod` and let bun resolve versions.

**Step 3: Create tsconfig.json**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "noEmit": true,
    "allowImportingTsExtensions": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

**Step 4: Create placeholder src/index.ts**

```ts
export {};
```

**Step 5: Install dependencies**

```bash
bun install
```

Verify: `bun build packages/kiste/src/index.ts --outdir /tmp/kiste-test --target bun` succeeds.

**Step 6: Commit**

```bash
git add packages/kiste/
git commit -m "chore(kiste): scaffold package with Effect TS deps"
```

---

## Task 2: Errors + Config Service

**Files:**
- Create: `packages/kiste/src/Errors.ts`
- Create: `packages/kiste/src/Config.ts`
- Create: `packages/kiste/src/Config.test.ts`

**Step 1: Write Errors.ts**

All tagged errors for the package. Keep in one file — there are only 4.

```ts
import { Data } from "effect";

export class ConfigError extends Data.TaggedError("ConfigError")<{
  readonly message: string;
}> {}

export class GitError extends Data.TaggedError("GitError")<{
  readonly command: string;
  readonly stderr: string;
  readonly exitCode?: number;
}> {}

export class IndexError extends Data.TaggedError("IndexError")<{
  readonly message: string;
  readonly cause?: unknown;
}> {}

export class DbError extends Data.TaggedError("DbError")<{
  readonly message: string;
  readonly cause?: unknown;
}> {}
```

**Step 2: Write Config.ts**

Config schema using Effect Schema (not Zod — Effect's own system). Service tag + live layer.

```ts
import { Context, Effect, Layer } from "effect";
import * as S from "@effect/schema/Schema";
import { ConfigError } from "./Errors.js";

export const KisteConfigSchema = S.Struct({
  strip_prefixes: S.optional(S.Array(S.String), {
    default: () => ["src", "lib", "components", "app", "pages"],
  }),
  stop_tags: S.optional(S.Array(S.String), {
    default: () => ["index", "utils", "helpers", "types"],
  }),
  snapshot_frequency: S.optional(S.Number, { default: () => 500 }),
  exclude: S.optional(S.Array(S.String), {
    default: () => ["node_modules/**", "dist/**", "*.lock"],
  }),
  db_path: S.optional(S.String, { default: () => ".kiste/index.sqlite" }),
});

export type KisteConfig = S.Schema.Type<typeof KisteConfigSchema>;

export class Config extends Context.Tag("kiste/Config")<Config, KisteConfig>() {}

export const ConfigLive = (repoDir: string) =>
  Layer.effect(
    Config,
    Effect.gen(function* () {
      const configPath = `${repoDir}/.kiste.yaml`;
      const file = Bun.file(configPath);
      const exists = yield* Effect.promise(() => file.exists());

      if (!exists) {
        return S.decodeUnknownSync(KisteConfigSchema)({});
      }

      const raw = yield* Effect.tryPromise({
        try: () => file.text(),
        catch: () => new ConfigError({ message: `Failed to read ${configPath}` }),
      });

      const parsed = yield* Effect.try({
        try: () => Bun.YAML.parse(raw),
        catch: () => new ConfigError({ message: `Invalid YAML in ${configPath}` }),
      });

      return yield* Effect.try({
        try: () => S.decodeUnknownSync(KisteConfigSchema)(parsed),
        catch: (e) =>
          new ConfigError({ message: `Invalid config: ${e instanceof Error ? e.message : String(e)}` }),
      });
    }),
  );
```

**Step 3: Write Config.test.ts**

```ts
import { describe, expect, test } from "bun:test";
import { Effect } from "effect";
import { Config, ConfigLive, KisteConfigSchema } from "./Config.js";
import * as S from "@effect/schema/Schema";

describe("KisteConfig", () => {
  test("defaults when no config", () => {
    const config = S.decodeUnknownSync(KisteConfigSchema)({});
    expect(config.strip_prefixes).toEqual(["src", "lib", "components", "app", "pages"]);
    expect(config.stop_tags).toEqual(["index", "utils", "helpers", "types"]);
    expect(config.snapshot_frequency).toBe(500);
    expect(config.db_path).toBe(".kiste/index.sqlite");
  });

  test("partial override merges with defaults", () => {
    const config = S.decodeUnknownSync(KisteConfigSchema)({
      strip_prefixes: ["src", "packages"],
      snapshot_frequency: 1000,
    });
    expect(config.strip_prefixes).toEqual(["src", "packages"]);
    expect(config.stop_tags).toEqual(["index", "utils", "helpers", "types"]);
    expect(config.snapshot_frequency).toBe(1000);
  });

  test("ConfigLive returns defaults for missing file", async () => {
    const config = await Effect.runPromise(
      Config.pipe(Effect.provide(ConfigLive("/nonexistent/path"))),
    );
    expect(config.strip_prefixes).toEqual(["src", "lib", "components", "app", "pages"]);
  });
});
```

**Step 4: Run tests**

```bash
bun test packages/kiste/src/Config.test.ts
```

Expected: 3 PASS.

**Step 5: Commit**

```bash
git add packages/kiste/src/Errors.ts packages/kiste/src/Config.ts packages/kiste/src/Config.test.ts
git commit -m "feat(kiste): add typed errors and config service with Effect Schema"
```

---

## Task 3: Tag Derivation (Pure Functions)

**Files:**
- Create: `packages/kiste/src/Tags.ts`
- Create: `packages/kiste/src/Tags.test.ts`

**Step 1: Write Tags.test.ts first (TDD)**

```ts
import { describe, expect, test } from "bun:test";
import {
  applyTagOperations,
  deriveTagsFromPath,
  parseConventionalCommit,
  parseTagLine,
} from "./Tags.js";
import type { KisteConfig } from "./Config.js";

const defaultConfig: Pick<KisteConfig, "strip_prefixes" | "stop_tags"> = {
  strip_prefixes: ["src", "lib", "components", "app", "pages"],
  stop_tags: ["index", "utils", "helpers", "types"],
};

describe("deriveTagsFromPath", () => {
  test("strips configured prefixes", () => {
    expect(deriveTagsFromPath("src/auth/session/handler.ts", defaultConfig)).toEqual([
      "auth",
      "session",
    ]);
  });

  test("strips multiple leading prefixes", () => {
    expect(deriveTagsFromPath("src/lib/auth/handler.ts", defaultConfig)).toEqual(["auth"]);
  });

  test("filters stop tags", () => {
    expect(deriveTagsFromPath("src/utils.ts", defaultConfig)).toEqual([]);
    expect(deriveTagsFromPath("lib/helpers/format.ts", defaultConfig)).toEqual([]);
  });

  test("preserves non-prefix non-stop segments", () => {
    expect(deriveTagsFromPath("packages/core/manifest/parser.ts", defaultConfig)).toEqual([
      "packages",
      "core",
      "manifest",
    ]);
  });

  test("handles root-level files", () => {
    expect(deriveTagsFromPath("README.md", defaultConfig)).toEqual([]);
  });

  test("drops file extension from filename", () => {
    expect(deriveTagsFromPath("auth/handler.test.ts", defaultConfig)).toEqual(["auth"]);
  });
});

describe("parseTagLine", () => {
  test("parses bare tags", () => {
    expect(parseTagLine("some body text\n\ntags: auth, redis, session")).toEqual([
      { tag: "auth", op: "add" },
      { tag: "redis", op: "add" },
      { tag: "session", op: "add" },
    ]);
  });

  test("parses +/- operators", () => {
    expect(parseTagLine("tags: +session, -auth, redis")).toEqual([
      { tag: "session", op: "add" },
      { tag: "auth", op: "remove" },
      { tag: "redis", op: "add" },
    ]);
  });

  test("returns null when no tag line", () => {
    expect(parseTagLine("just a normal commit body")).toBeNull();
  });

  test("finds tags: line anywhere in body", () => {
    expect(parseTagLine("line one\ntags: foo\nline three")).toEqual([
      { tag: "foo", op: "add" },
    ]);
  });
});

describe("parseConventionalCommit", () => {
  test("parses type and scope", () => {
    expect(parseConventionalCommit("feat(auth): add login")).toEqual({
      type: "feat",
      scope: "auth",
    });
  });

  test("parses type without scope", () => {
    expect(parseConventionalCommit("fix: correct typo")).toEqual({
      type: "fix",
      scope: null,
    });
  });

  test("returns null for non-conventional", () => {
    expect(parseConventionalCommit("Update readme")).toBeNull();
  });

  test("handles breaking change indicator", () => {
    expect(parseConventionalCommit("feat(api)!: remove endpoint")).toEqual({
      type: "feat",
      scope: "api",
    });
  });
});

describe("applyTagOperations", () => {
  test("adds tags", () => {
    const result = applyTagOperations(new Set(), [{ tag: "auth", op: "add" }]);
    expect(result).toEqual(new Set(["auth"]));
  });

  test("removes tags", () => {
    const result = applyTagOperations(new Set(["auth", "redis"]), [
      { tag: "auth", op: "remove" },
    ]);
    expect(result).toEqual(new Set(["redis"]));
  });

  test("removing non-existent tag is no-op", () => {
    const result = applyTagOperations(new Set(["auth"]), [
      { tag: "nonexistent", op: "remove" },
    ]);
    expect(result).toEqual(new Set(["auth"]));
  });

  test("replays sequence correctly", () => {
    const result = applyTagOperations(new Set(), [
      { tag: "auth", op: "add" },
      { tag: "redis", op: "add" },
      { tag: "auth", op: "remove" },
      { tag: "session", op: "add" },
    ]);
    expect(result).toEqual(new Set(["redis", "session"]));
  });
});
```

**Step 2: Run tests to verify they fail**

```bash
bun test packages/kiste/src/Tags.test.ts
```

Expected: FAIL — `Tags.js` doesn't exist yet.

**Step 3: Write Tags.ts**

```ts
import type { KisteConfig } from "./Config.js";

export type TagOperation = { readonly tag: string; readonly op: "add" | "remove" };

const EXTENSION_RE = /\.[^.]+$/;
const CONVENTIONAL_RE = /^(\w+)(?:\(([^)]+)\))?!?:\s/;
const TAG_LINE_RE = /^tags:\s*(.+)$/m;

export function deriveTagsFromPath(
  filePath: string,
  config: Pick<KisteConfig, "strip_prefixes" | "stop_tags">,
): string[] {
  const segments = filePath.split("/");
  // Drop the filename (last segment)
  const dirs = segments.slice(0, -1);

  // Strip leading segments that match strip_prefixes
  const stripped: string[] = [];
  let stripping = true;
  for (const seg of dirs) {
    if (stripping && config.strip_prefixes.includes(seg)) {
      continue;
    }
    stripping = false;
    if (!config.stop_tags.includes(seg)) {
      stripped.push(seg);
    }
  }

  return stripped;
}

export function parseTagLine(body: string): TagOperation[] | null {
  const match = body.match(TAG_LINE_RE);
  if (!match) return null;

  return match[1].split(",").map((raw) => {
    const trimmed = raw.trim();
    if (trimmed.startsWith("+")) {
      return { tag: trimmed.slice(1), op: "add" as const };
    }
    if (trimmed.startsWith("-")) {
      return { tag: trimmed.slice(1), op: "remove" as const };
    }
    return { tag: trimmed, op: "add" as const };
  });
}

export function parseConventionalCommit(
  subject: string,
): { type: string; scope: string | null } | null {
  const match = subject.match(CONVENTIONAL_RE);
  if (!match) return null;
  return { type: match[1], scope: match[2] ?? null };
}

export function applyTagOperations(current: Set<string>, ops: TagOperation[]): Set<string> {
  const result = new Set(current);
  for (const op of ops) {
    if (op.op === "add") {
      result.add(op.tag);
    } else {
      result.delete(op.tag);
    }
  }
  return result;
}
```

**Step 4: Run tests**

```bash
bun test packages/kiste/src/Tags.test.ts
```

Expected: All PASS.

**Step 5: Commit**

```bash
git add packages/kiste/src/Tags.ts packages/kiste/src/Tags.test.ts
git commit -m "feat(kiste): add tag derivation and parsing (pure functions)"
```

---

## Task 4: Database Schema + Service

**Files:**
- Create: `packages/kiste/src/Db.ts`

This task sets up the SQLite schema and provides it as an Effect layer. Testing happens via the indexer integration tests in Task 6.

**Step 1: Write Db.ts**

```ts
import { SqliteClient } from "@effect/sql-sqlite-bun";
import { SqlClient } from "@effect/sql";
import { Effect, Layer } from "effect";
import { DbError } from "./Errors.js";

const SCHEMA_SQL = `
CREATE TABLE IF NOT EXISTS artifacts (
  id          INTEGER PRIMARY KEY,
  path        TEXT NOT NULL UNIQUE,
  alive       INTEGER NOT NULL DEFAULT 1
);

CREATE TABLE IF NOT EXISTS commits (
  sha         TEXT PRIMARY KEY,
  message     TEXT NOT NULL,
  author      TEXT NOT NULL,
  timestamp   INTEGER NOT NULL,
  conv_type   TEXT,
  conv_scope  TEXT
);

CREATE TABLE IF NOT EXISTS artifact_commits (
  artifact_id INTEGER REFERENCES artifacts(id),
  commit_sha  TEXT REFERENCES commits(sha),
  PRIMARY KEY (artifact_id, commit_sha)
);

CREATE TABLE IF NOT EXISTS artifact_tags (
  artifact_id INTEGER REFERENCES artifacts(id),
  tag         TEXT NOT NULL,
  PRIMARY KEY (artifact_id, tag)
);

CREATE TABLE IF NOT EXISTS tag_operations (
  id          INTEGER PRIMARY KEY,
  artifact_id INTEGER REFERENCES artifacts(id),
  commit_sha  TEXT REFERENCES commits(sha),
  tag         TEXT NOT NULL,
  op          TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS meta (
  key         TEXT PRIMARY KEY,
  value       TEXT NOT NULL
);

CREATE VIRTUAL TABLE IF NOT EXISTS commits_fts USING fts5(
  message,
  content=commits,
  content_rowid=rowid
);

CREATE TRIGGER IF NOT EXISTS commits_fts_insert AFTER INSERT ON commits BEGIN
  INSERT INTO commits_fts(rowid, message) VALUES (new.rowid, new.message);
END;
`;

export const initSchema = Effect.gen(function* () {
  const sql = yield* SqlClient.SqlClient;
  // bun:sqlite supports executing multiple statements, but @effect/sql may not.
  // Split and execute individually.
  for (const stmt of SCHEMA_SQL.split(";").filter((s) => s.trim())) {
    yield* sql.unsafe(stmt);
  }
});

export const getLastIndexedSha = Effect.gen(function* () {
  const sql = yield* SqlClient.SqlClient;
  const rows = yield* sql<{ value: string }>`SELECT value FROM meta WHERE key = 'last_indexed_sha'`;
  return rows.length > 0 ? rows[0].value : null;
});

export const setLastIndexedSha = (sha: string) =>
  Effect.gen(function* () {
    const sql = yield* SqlClient.SqlClient;
    yield* sql`INSERT OR REPLACE INTO meta (key, value) VALUES ('last_indexed_sha', ${sha})`;
  });

export const DbLive = (dbPath: string) =>
  SqliteClient.layer({
    filename: dbPath,
  });
```

Note: The `@effect/sql-sqlite-bun` API may differ from what's shown. Consult the `effect-ts:platform` skill and `@effect/sql-sqlite-bun` source for exact layer construction. The `SqlClient.SqlClient` tag provides the tagged template API.

**Step 2: Verify it compiles**

```bash
bun build packages/kiste/src/Db.ts --outdir /tmp/kiste-test --target bun --no-bundle 2>&1 | head -5
```

Expected: No errors.

**Step 3: Commit**

```bash
git add packages/kiste/src/Db.ts
git commit -m "feat(kiste): add SQLite schema and db service layer"
```

---

## Task 5: Git Service

**Files:**
- Create: `packages/kiste/src/Git.ts`

Git service wraps `@effect/platform` Command for subprocess execution. Provides structured parsing of `git log` output.

**Step 1: Write Git.ts**

```ts
import { Command } from "@effect/platform";
import { Context, Effect, Layer } from "effect";
import { GitError } from "./Errors.js";

export interface RawCommit {
  readonly sha: string;
  readonly author: string;
  readonly timestamp: number;
  readonly subject: string;
  readonly body: string;
  readonly files: readonly string[];
  readonly deletedFiles: readonly string[];
}

const COMMIT_DELIM = "---KISTE-COMMIT---";

// git log format: delimiter, then sha, author, timestamp, subject, body, then --name-status for files
const LOG_FORMAT = `${COMMIT_DELIM}%n%H%n%an%n%at%n%s%n%b%n---KISTE-FILES---`;

export class Git extends Context.Tag("kiste/Git")<
  Git,
  {
    readonly revParse: (cwd: string, ref?: string) => Effect.Effect<string, GitError>;
    readonly log: (cwd: string, since?: string) => Effect.Effect<readonly RawCommit[], GitError>;
    readonly show: (cwd: string, ref: string, path: string) => Effect.Effect<string, GitError>;
  }
>() {}

const runGit = (args: string[], cwd: string) =>
  Command.make("git", ...args).pipe(
    Command.workingDirectory(cwd),
    Command.string,
    Effect.mapError(
      (e) => new GitError({ command: `git ${args.join(" ")}`, stderr: String(e) }),
    ),
  );

export function parseGitLogOutput(raw: string): RawCommit[] {
  const blocks = raw.split(COMMIT_DELIM).filter((b) => b.trim());
  const commits: RawCommit[] = [];

  for (const block of blocks) {
    const [filesSection, ...rest] = block.split("---KISTE-FILES---");
    const lines = filesSection.trim().split("\n");

    if (lines.length < 4) continue;

    const sha = lines[0];
    const author = lines[1];
    const timestamp = parseInt(lines[2], 10);
    const subject = lines[3];
    const body = lines.slice(4).join("\n").trim();

    // Parse --name-status output after the FILES delimiter
    const fileLines = (rest.join("") || "").trim().split("\n").filter(Boolean);
    const files: string[] = [];
    const deletedFiles: string[] = [];

    for (const line of fileLines) {
      const status = line[0];
      const path = line.slice(1).trim();
      if (!path) continue;
      if (status === "D") {
        deletedFiles.push(path);
      } else {
        files.push(path);
      }
    }

    commits.push({ sha, author, timestamp, subject, body, files, deletedFiles });
  }

  return commits;
}

export const GitLive = Layer.succeed(Git, {
  revParse: (cwd, ref = "HEAD") =>
    runGit(["rev-parse", ref], cwd).pipe(Effect.map((s) => s.trim())),

  log: (cwd, since) => {
    const range = since ? [`${since}..HEAD`] : [];
    return runGit(
      ["log", `--pretty=format:${LOG_FORMAT}`, "--name-status", ...range],
      cwd,
    ).pipe(
      Effect.map((raw) => parseGitLogOutput(raw).reverse()), // reverse: oldest first
    );
  },

  show: (cwd, ref, path) => runGit(["show", `${ref}:${path}`], cwd),
});
```

Note: `@effect/platform` Command API — consult `effect-ts:platform` skill for exact import paths and pipe syntax. The `Command.string` function captures stdout as a string. `Command.workingDirectory` sets cwd. Provide `BunContext.layer` at runtime.

**Step 2: Verify it compiles**

```bash
bun build packages/kiste/src/Git.ts --outdir /tmp/kiste-test --target bun --no-bundle 2>&1 | head -5
```

**Step 3: Commit**

```bash
git add packages/kiste/src/Git.ts
git commit -m "feat(kiste): add git service with log parsing"
```

---

## Task 6: Indexer + Integration Tests

**Files:**
- Create: `packages/kiste/src/Indexer.ts`
- Create: `packages/kiste/src/Indexer.test.ts`

This is the core orchestrator — the most complex piece.

**Step 1: Write Indexer.test.ts first (TDD)**

Tests use real temp git repos created via `Bun.spawnSync`.

```ts
import { afterEach, beforeEach, describe, expect, test } from "bun:test";
import { Effect, Layer } from "effect";
import { SqlClient } from "@effect/sql";
import { SqliteClient } from "@effect/sql-sqlite-bun";
import { mkdtempSync, rmSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { Config, type KisteConfig } from "./Config.js";
import { initSchema, getLastIndexedSha } from "./Db.js";
import { Git, GitLive } from "./Git.js";
import { incrementalIndex, rebuildIndex } from "./Indexer.js";
import { BunContext } from "@effect/platform-bun";
import * as S from "@effect/schema/Schema";
import { KisteConfigSchema } from "./Config.js";

function git(cwd: string, ...args: string[]) {
  const result = Bun.spawnSync(["git", ...args], { cwd, stdout: "pipe", stderr: "pipe" });
  if (!result.success) throw new Error(`git ${args.join(" ")} failed: ${result.stderr.toString()}`);
  return result.stdout.toString().trim();
}

function createTempRepo(): string {
  const dir = mkdtempSync(join(tmpdir(), "kiste-test-"));
  git(dir, "init");
  git(dir, "config", "user.email", "test@test.com");
  git(dir, "config", "user.name", "Test");
  return dir;
}

function makeTestLayer(repoDir: string) {
  const dbPath = join(repoDir, ".kiste", "index.sqlite");
  Bun.spawnSync(["mkdir", "-p", join(repoDir, ".kiste")]);

  const config = S.decodeUnknownSync(KisteConfigSchema)({});
  return Layer.mergeAll(
    Layer.succeed(Config, config),
    SqliteClient.layer({ filename: dbPath }),
    GitLive,
    BunContext.layer,
  );
}

describe("Indexer", () => {
  let repoDir: string;

  beforeEach(() => {
    repoDir = createTempRepo();
  });

  afterEach(() => {
    rmSync(repoDir, { recursive: true, force: true });
  });

  test("indexes a single commit", async () => {
    writeFileSync(join(repoDir, "auth", "handler.ts"), "export default {};", { recursive: true });
    Bun.spawnSync(["mkdir", "-p", join(repoDir, "auth")]);
    writeFileSync(join(repoDir, "auth", "handler.ts"), "export default {};");
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "feat(auth): add handler");

    const layer = makeTestLayer(repoDir);

    const result = await Effect.runPromise(
      Effect.gen(function* () {
        yield* initSchema;
        return yield* rebuildIndex(repoDir);
      }).pipe(Effect.provide(layer)),
    );

    expect(result.commits_indexed).toBe(1);
    expect(result.artifacts_indexed).toBeGreaterThanOrEqual(1);
  });

  test("tracks file deletion", async () => {
    writeFileSync(join(repoDir, "temp.ts"), "export {};");
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "feat: add temp file");

    Bun.spawnSync(["rm", join(repoDir, "temp.ts")]);
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "chore: remove temp file");

    const layer = makeTestLayer(repoDir);

    await Effect.runPromise(
      Effect.gen(function* () {
        yield* initSchema;
        yield* rebuildIndex(repoDir);
        const sql = yield* SqlClient.SqlClient;
        const rows = yield* sql<{ alive: number }>`SELECT alive FROM artifacts WHERE path = 'temp.ts'`;
        expect(rows[0].alive).toBe(0);
      }).pipe(Effect.provide(layer)),
    );
  });

  test("incremental index skips already-indexed commits", async () => {
    writeFileSync(join(repoDir, "a.ts"), "a");
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "feat: add a");

    const layer = makeTestLayer(repoDir);

    await Effect.runPromise(
      Effect.gen(function* () {
        yield* initSchema;
        const r1 = yield* incrementalIndex(repoDir);
        expect(r1.commits_indexed).toBe(1);

        // Second run: no new commits
        const r2 = yield* incrementalIndex(repoDir);
        expect(r2.commits_indexed).toBe(0);

        // Add a new commit
        writeFileSync(join(repoDir, "b.ts"), "b");
        Bun.spawnSync(["git", "add", "."], { cwd: repoDir });
        Bun.spawnSync(["git", "commit", "-m", "feat: add b"], { cwd: repoDir });

        // Third run: only new commit
        const r3 = yield* incrementalIndex(repoDir);
        expect(r3.commits_indexed).toBe(1);
      }).pipe(Effect.provide(layer)),
    );
  });

  test("derives folder tags from paths", async () => {
    Bun.spawnSync(["mkdir", "-p", join(repoDir, "src", "auth")]);
    writeFileSync(join(repoDir, "src", "auth", "login.ts"), "export {};");
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "feat(auth): add login");

    const layer = makeTestLayer(repoDir);

    await Effect.runPromise(
      Effect.gen(function* () {
        yield* initSchema;
        yield* rebuildIndex(repoDir);
        const sql = yield* SqlClient.SqlClient;
        const tags = yield* sql<{ tag: string }>`
          SELECT at.tag FROM artifact_tags at
          JOIN artifacts a ON a.id = at.artifact_id
          WHERE a.path = 'src/auth/login.ts'
        `;
        expect(tags.map((t) => t.tag).sort()).toEqual(["auth"]);
      }).pipe(Effect.provide(layer)),
    );
  });
});
```

Note: Exact `@effect/sql` tagged template syntax and layer composition may need adjustment — consult the `effect-ts:platform` skill and `@effect/sql-sqlite-bun` source for exact API.

**Step 2: Run tests to verify they fail**

```bash
bun test packages/kiste/src/Indexer.test.ts
```

Expected: FAIL — `Indexer.ts` doesn't exist yet.

**Step 3: Write Indexer.ts**

```ts
import { Effect } from "effect";
import { SqlClient } from "@effect/sql";
import { Config } from "./Config.js";
import { Git, type RawCommit } from "./Git.js";
import { IndexError } from "./Errors.js";
import { getLastIndexedSha, setLastIndexedSha } from "./Db.js";
import { applyTagOperations, deriveTagsFromPath, parseConventionalCommit, parseTagLine } from "./Tags.js";

export interface IndexResult {
  readonly commits_indexed: number;
  readonly artifacts_indexed: number;
  readonly artifacts_deleted: number;
}

const indexCommit = (commit: RawCommit) =>
  Effect.gen(function* () {
    const sql = yield* SqlClient.SqlClient;
    const config = yield* Config;

    const conv = parseConventionalCommit(commit.subject);

    // Insert commit
    yield* sql`
      INSERT OR IGNORE INTO commits (sha, message, author, timestamp, conv_type, conv_scope)
      VALUES (${commit.sha}, ${commit.subject + "\n" + commit.body}, ${commit.author}, ${commit.timestamp}, ${conv?.type ?? null}, ${conv?.scope ?? null})
    `;

    let artifactsIndexed = 0;
    let artifactsDeleted = 0;

    // Process added/modified files
    for (const path of commit.files) {
      yield* sql`INSERT OR IGNORE INTO artifacts (path, alive) VALUES (${path}, 1)`;
      yield* sql`UPDATE artifacts SET alive = 1 WHERE path = ${path}`;

      const rows = yield* sql<{ id: number }>`SELECT id FROM artifacts WHERE path = ${path}`;
      const artifactId = rows[0].id;

      yield* sql`INSERT OR IGNORE INTO artifact_commits (artifact_id, commit_sha) VALUES (${artifactId}, ${commit.sha})`;

      // Tag operations from commit body
      const tagOps = parseTagLine(commit.body);
      if (tagOps) {
        for (const op of tagOps) {
          yield* sql`INSERT INTO tag_operations (artifact_id, commit_sha, tag, op) VALUES (${artifactId}, ${commit.sha}, ${op.tag}, ${op.op})`;
        }
      }

      // Materialize tags: replay all tag_operations for this artifact
      const allOps = yield* sql<{ tag: string; op: string }>`
        SELECT to2.tag, to2.op FROM tag_operations to2
        JOIN commits c ON c.sha = to2.commit_sha
        WHERE to2.artifact_id = ${artifactId}
        ORDER BY c.timestamp ASC, to2.id ASC
      `;

      // Start with folder-derived tags
      const folderTags = deriveTagsFromPath(path, config);
      let currentTags = new Set(folderTags);
      currentTags = applyTagOperations(
        currentTags,
        allOps.map((r) => ({ tag: r.tag, op: r.op as "add" | "remove" })),
      );

      // Replace artifact_tags
      yield* sql`DELETE FROM artifact_tags WHERE artifact_id = ${artifactId}`;
      for (const tag of currentTags) {
        yield* sql`INSERT INTO artifact_tags (artifact_id, tag) VALUES (${artifactId}, ${tag})`;
      }

      artifactsIndexed++;
    }

    // Process deleted files
    for (const path of commit.deletedFiles) {
      yield* sql`UPDATE artifacts SET alive = 0 WHERE path = ${path}`;

      const rows = yield* sql<{ id: number }>`SELECT id FROM artifacts WHERE path = ${path}`;
      if (rows.length > 0) {
        yield* sql`INSERT OR IGNORE INTO artifact_commits (artifact_id, commit_sha) VALUES (${rows[0].id}, ${commit.sha})`;
      }
      artifactsDeleted++;
    }

    return { artifactsIndexed, artifactsDeleted };
  });

export const rebuildIndex = (cwd: string) =>
  Effect.gen(function* () {
    const git = yield* Git;
    const commits = yield* git.log(cwd); // oldest first (Git service reverses)

    let totalArtifacts = 0;
    let totalDeleted = 0;

    for (const commit of commits) {
      const result = yield* indexCommit(commit);
      totalArtifacts += result.artifactsIndexed;
      totalDeleted += result.artifactsDeleted;
    }

    if (commits.length > 0) {
      yield* setLastIndexedSha(commits[commits.length - 1].sha);
    }

    return {
      commits_indexed: commits.length,
      artifacts_indexed: totalArtifacts,
      artifacts_deleted: totalDeleted,
    } satisfies IndexResult;
  });

export const incrementalIndex = (cwd: string) =>
  Effect.gen(function* () {
    const git = yield* Git;
    const lastSha = yield* getLastIndexedSha;
    const currentSha = yield* git.revParse(cwd);

    if (lastSha === currentSha) {
      return { commits_indexed: 0, artifacts_indexed: 0, artifacts_deleted: 0 } satisfies IndexResult;
    }

    const commits = yield* git.log(cwd, lastSha ?? undefined);

    let totalArtifacts = 0;
    let totalDeleted = 0;

    for (const commit of commits) {
      const result = yield* indexCommit(commit);
      totalArtifacts += result.artifactsIndexed;
      totalDeleted += result.artifactsDeleted;
    }

    if (commits.length > 0) {
      yield* setLastIndexedSha(commits[commits.length - 1].sha);
    }

    return {
      commits_indexed: commits.length,
      artifacts_indexed: totalArtifacts,
      artifacts_deleted: totalDeleted,
    } satisfies IndexResult;
  });
```

Note: The `@effect/sql` tagged template may need `sql.unsafe()` for some operations, or the parameterized syntax may differ. Consult the `effect-ts:platform` skill for exact patterns. The above is the logical structure — adjust syntax to match the actual API.

**Step 4: Run tests**

```bash
bun test packages/kiste/src/Indexer.test.ts
```

Expected: All PASS. If any fail, debug with the `systematic-debugging` skill.

**Step 5: Commit**

```bash
git add packages/kiste/src/Indexer.ts packages/kiste/src/Indexer.test.ts
git commit -m "feat(kiste): add indexer with incremental indexing and tag materialization"
```

---

## Task 7: CLI

**Files:**
- Create: `packages/kiste/src/Cli.ts`

Uses `@effect/cli` for subcommand dispatch with built-in `--help` and `--version`.

**Step 1: Write Cli.ts**

```ts
#!/usr/bin/env bun

import { Args, Command, Options } from "@effect/cli";
import { BunContext, BunRuntime } from "@effect/platform-bun";
import { Console, Effect, Layer } from "effect";
import { SqlClient } from "@effect/sql";
import { Config, ConfigLive } from "./Config.js";
import { DbLive, initSchema } from "./Db.js";
import { GitLive } from "./Git.js";
import { incrementalIndex, rebuildIndex } from "./Indexer.js";
import { resolve } from "node:path";

// ── init ──

const initCmd = Command.make("init", {}, () =>
  Effect.gen(function* () {
    const cwd = process.cwd();
    const configPath = resolve(cwd, ".kiste.yaml");
    const dbDir = resolve(cwd, ".kiste");

    yield* Effect.promise(() => Bun.write(configPath, [
      "# kiste configuration",
      "# strip_prefixes: [src, lib, components, app, pages]",
      "# stop_tags: [index, utils, helpers, types]",
      "# snapshot_frequency: 500",
      "# exclude: ['node_modules/**', 'dist/**', '*.lock']",
    ].join("\n")));

    yield* Effect.promise(async () => {
      const proc = Bun.spawnSync(["mkdir", "-p", dbDir]);
      if (!proc.success) throw new Error("Failed to create .kiste directory");
    });

    yield* Console.log(`Initialized kiste in ${cwd}`);
    yield* Console.log(`  Config: ${configPath}`);
    yield* Console.log(`  Database: ${dbDir}/index.sqlite`);
  }),
);

// ── index ──

const indexCmd = Command.make(
  "index",
  { rebuild: Options.boolean("rebuild").pipe(Options.withDefault(false)) },
  ({ rebuild }) =>
    Effect.gen(function* () {
      const cwd = process.cwd();
      yield* initSchema;
      const result = rebuild ? yield* rebuildIndex(cwd) : yield* incrementalIndex(cwd);
      yield* Console.log(`Indexed ${result.commits_indexed} commits`);
      yield* Console.log(`  Artifacts: ${result.artifacts_indexed} indexed, ${result.artifacts_deleted} deleted`);
    }),
);

// ── status ──

const statusCmd = Command.make("status", {}, () =>
  Effect.gen(function* () {
    const sql = yield* SqlClient.SqlClient;
    yield* initSchema;

    const [commits] = yield* sql<{ count: number }>`SELECT COUNT(*) as count FROM commits`;
    const [artifacts] = yield* sql<{ count: number }>`SELECT COUNT(*) as count FROM artifacts WHERE alive = 1`;
    const [deleted] = yield* sql<{ count: number }>`SELECT COUNT(*) as count FROM artifacts WHERE alive = 0`;
    const [tags] = yield* sql<{ count: number }>`SELECT COUNT(DISTINCT tag) as count FROM artifact_tags`;
    const meta = yield* sql<{ value: string }>`SELECT value FROM meta WHERE key = 'last_indexed_sha'`;

    yield* Console.log("kiste status:");
    yield* Console.log(`  Commits:   ${commits.count}`);
    yield* Console.log(`  Artifacts: ${artifacts.count} alive, ${deleted.count} deleted`);
    yield* Console.log(`  Tags:      ${tags.count} unique`);
    yield* Console.log(`  Last SHA:  ${meta.length > 0 ? meta[0].value.slice(0, 12) : "(not indexed)"}`);
  }),
);

// ── query ──

const queryCmd = Command.make(
  "query",
  { tags: Options.text("tags").pipe(Options.withDescription("Comma-separated tags")) },
  ({ tags }) =>
    Effect.gen(function* () {
      const sql = yield* SqlClient.SqlClient;
      const tagList = tags.split(",").map((t) => t.trim());

      // Artifacts that have ALL the requested tags
      const rows = yield* sql<{ path: string; tags: string }>`
        SELECT a.path, GROUP_CONCAT(at2.tag) as tags
        FROM artifacts a
        JOIN artifact_tags at ON a.id = at.artifact_id
        LEFT JOIN artifact_tags at2 ON a.id = at2.artifact_id
        WHERE a.alive = 1 AND at.tag IN ${sql.in(tagList)}
        GROUP BY a.id
        HAVING COUNT(DISTINCT at.tag) = ${tagList.length}
        ORDER BY a.path
      `;

      yield* Console.log(`${rows.length} artifacts matching tags: ${tags}`);
      for (const row of rows) {
        yield* Console.log(`  ${row.path}  [${row.tags}]`);
      }
    }),
);

// ── root ──

const rootCmd = Command.make("kiste", {}).pipe(
  Command.withSubcommands([initCmd, indexCmd, statusCmd, queryCmd]),
);

// ── main ──

const appLayer = (cwd: string) =>
  Layer.mergeAll(
    ConfigLive(cwd),
    DbLive(resolve(cwd, ".kiste", "index.sqlite")),
    GitLive,
    BunContext.layer,
  );

const cli = Command.run(rootCmd, {
  name: "kiste",
  version: "0.1.0",
});

cli(process.argv).pipe(Effect.provide(appLayer(process.cwd())), BunRuntime.runMain);
```

Note: `@effect/cli` API (Options, Args, Command) — consult the `effect-ts:effect-core` and platform skills for exact pipe patterns. The `sql.in()` helper may not exist; use `sql.unsafe` with manual parameter binding if needed.

**Step 2: Build and test manually**

```bash
bun run --cwd packages/kiste build
bun run packages/kiste/dist/cli.js --help
bun run packages/kiste/dist/cli.js init
bun run packages/kiste/dist/cli.js index
bun run packages/kiste/dist/cli.js status
```

**Step 3: Commit**

```bash
git add packages/kiste/src/Cli.ts
git commit -m "feat(kiste): add CLI with init, index, status, query subcommands"
```

---

## Task 8: MCP Tools + Server

**Files:**
- Create: `packages/kiste/src/tool-registry.ts` (copy from `packages/mcp/src/tool-registry.ts`)
- Create: `packages/kiste/src/Tools.ts`
- Create: `packages/kiste/src/Mcp.ts`
- Create: `packages/kiste/src/Tools.test.ts`

**Step 1: Copy tool-registry.ts**

Copy `packages/mcp/src/tool-registry.ts` verbatim into `packages/kiste/src/tool-registry.ts`. This keeps the package standalone.

**Step 2: Write Tools.ts**

MCP tool definitions. Input schemas use Zod (MCP SDK requirement). Handlers are Effect programs run via `Effect.runPromise`.

```ts
import { z } from "zod";
import { Effect, Layer } from "effect";
import { SqlClient } from "@effect/sql";
import type { ToolDef } from "./tool-registry.js";
import { Git } from "./Git.js";
import { Config, ConfigLive } from "./Config.js";
import { DbLive } from "./Db.js";
import { GitLive } from "./Git.js";
import { BunContext } from "@effect/platform-bun";
import type { ToolAnnotations } from "@modelcontextprotocol/sdk/types.js";

const READ_ONLY: ToolAnnotations = {
  readOnlyHint: true,
  destructiveHint: false,
  idempotentHint: true,
  openWorldHint: false,
};

const dbPath = z.string().describe("Path to kiste SQLite database");
const repoDir = z.string().optional().describe("Repository root directory (default: cwd)");

const makeLayer = (db_path: string, repo_dir: string) =>
  Layer.mergeAll(
    ConfigLive(repo_dir),
    DbLive(db_path),
    GitLive,
    BunContext.layer,
  );

const runEffect = <A>(effect: Effect.Effect<A, unknown, any>, db_path: string, repo_dir?: string) =>
  Effect.runPromise(effect.pipe(Effect.provide(makeLayer(db_path, repo_dir ?? process.cwd()))));

export const tools: ToolDef[] = [
  {
    name: "kiste_list_artifacts",
    description: "List artifacts, optionally filtered by tags. Returns summaries (no content).",
    annotations: READ_ONLY,
    inputSchema: {
      db_path: dbPath,
      repo_dir: repoDir,
      tags: z.array(z.string()).optional().describe("Filter to artifacts with ALL these tags"),
      include_deleted: z.boolean().optional().default(false),
      limit: z.number().int().positive().optional().default(50),
      offset: z.number().int().nonnegative().optional().default(0),
    },
    handler: async ({ db_path, repo_dir, tags, include_deleted, limit, offset }) =>
      runEffect(
        Effect.gen(function* () {
          const sql = yield* SqlClient.SqlClient;
          // Implementation: SQL query with tag filter, alive filter, pagination
          if (tags && tags.length > 0) {
            return yield* sql`
              SELECT a.path, a.alive, GROUP_CONCAT(DISTINCT at2.tag) as tags
              FROM artifacts a
              JOIN artifact_tags at ON a.id = at.artifact_id
              LEFT JOIN artifact_tags at2 ON a.id = at2.artifact_id
              WHERE ${include_deleted ? sql`1=1` : sql`a.alive = 1`}
                AND at.tag IN ${sql.in(tags)}
              GROUP BY a.id
              HAVING COUNT(DISTINCT at.tag) = ${tags.length}
              ORDER BY a.path
              LIMIT ${limit} OFFSET ${offset}
            `;
          }
          return yield* sql`
            SELECT a.path, a.alive, GROUP_CONCAT(DISTINCT at.tag) as tags
            FROM artifacts a
            LEFT JOIN artifact_tags at ON a.id = at.artifact_id
            WHERE ${include_deleted ? sql`1=1` : sql`a.alive = 1`}
            GROUP BY a.id
            ORDER BY a.path
            LIMIT ${limit} OFFSET ${offset}
          `;
        }),
        db_path,
        repo_dir,
      ),
  },

  {
    name: "kiste_get_artifact",
    description: "Get artifact content (from git), tags, and commit history.",
    annotations: READ_ONLY,
    inputSchema: {
      db_path: dbPath,
      repo_dir: repoDir,
      path: z.string().describe("File path of the artifact"),
      ref: z.string().optional().default("HEAD").describe("Git ref for content (default: HEAD)"),
    },
    handler: async ({ db_path, repo_dir, path, ref }) =>
      runEffect(
        Effect.gen(function* () {
          const sql = yield* SqlClient.SqlClient;
          const git = yield* Git;
          const cwd = repo_dir ?? process.cwd();

          const [artifact] = yield* sql<{ id: number; alive: number }>`
            SELECT id, alive FROM artifacts WHERE path = ${path}
          `;
          if (!artifact) return { error: `Artifact not found: ${path}` };

          const tags = yield* sql<{ tag: string }>`
            SELECT tag FROM artifact_tags WHERE artifact_id = ${artifact.id}
          `;

          const commits = yield* sql<{ sha: string; message: string; author: string; timestamp: number }>`
            SELECT c.sha, c.message, c.author, c.timestamp
            FROM commits c
            JOIN artifact_commits ac ON c.sha = ac.commit_sha
            WHERE ac.artifact_id = ${artifact.id}
            ORDER BY c.timestamp DESC
          `;

          const content = artifact.alive
            ? yield* git.show(cwd, ref, path).pipe(Effect.catchAll(() => Effect.succeed(null)))
            : null;

          return {
            path,
            alive: artifact.alive === 1,
            content,
            tags: tags.map((t) => t.tag),
            commits: commits.map((c) => ({
              sha: c.sha,
              message: c.message,
              author: c.author,
              timestamp: c.timestamp,
            })),
          };
        }),
        db_path,
        repo_dir,
      ),
  },

  {
    name: "kiste_search",
    description: "Full-text search over commit messages. Returns matching artifacts with scores.",
    annotations: READ_ONLY,
    inputSchema: {
      db_path: dbPath,
      repo_dir: repoDir,
      query: z.string().describe("Search query"),
      tags: z.array(z.string()).optional().describe("Filter to artifacts with these tags"),
      limit: z.number().int().positive().optional().default(20),
    },
    handler: async ({ db_path, repo_dir, query, tags, limit }) =>
      runEffect(
        Effect.gen(function* () {
          const sql = yield* SqlClient.SqlClient;
          return yield* sql`
            SELECT DISTINCT a.path, rank
            FROM commits_fts f
            JOIN commits c ON f.rowid = c.rowid
            JOIN artifact_commits ac ON c.sha = ac.commit_sha
            JOIN artifacts a ON ac.artifact_id = a.id
            WHERE commits_fts MATCH ${query} AND a.alive = 1
            ORDER BY rank
            LIMIT ${limit}
          `;
        }),
        db_path,
        repo_dir,
      ),
  },

  {
    name: "kiste_get_provenance",
    description: "Full commit history for an artifact, oldest first.",
    annotations: READ_ONLY,
    inputSchema: {
      db_path: dbPath,
      repo_dir: repoDir,
      path: z.string().describe("File path of the artifact"),
    },
    handler: async ({ db_path, repo_dir, path }) =>
      runEffect(
        Effect.gen(function* () {
          const sql = yield* SqlClient.SqlClient;
          return yield* sql`
            SELECT c.sha, c.message, c.author, c.timestamp, c.conv_type, c.conv_scope
            FROM commits c
            JOIN artifact_commits ac ON c.sha = ac.commit_sha
            JOIN artifacts a ON ac.artifact_id = a.id
            WHERE a.path = ${path}
            ORDER BY c.timestamp ASC
          `;
        }),
        db_path,
        repo_dir,
      ),
  },

  {
    name: "kiste_list_tags",
    description: "All tags in the index with artifact counts.",
    annotations: READ_ONLY,
    inputSchema: {
      db_path: dbPath,
      repo_dir: repoDir,
    },
    handler: async ({ db_path, repo_dir }) =>
      runEffect(
        Effect.gen(function* () {
          const sql = yield* SqlClient.SqlClient;
          return yield* sql`
            SELECT tag, COUNT(*) as count
            FROM artifact_tags at
            JOIN artifacts a ON a.id = at.artifact_id
            WHERE a.alive = 1
            GROUP BY tag
            ORDER BY count DESC
          `;
        }),
        db_path,
        repo_dir,
      ),
  },
];
```

**Step 3: Write Mcp.ts**

```ts
#!/usr/bin/env bun

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { registerTools } from "./tool-registry.js";
import { tools } from "./Tools.js";

export function createServer(): McpServer {
  const server = new McpServer({ name: "kiste", version: "0.1.0" });
  registerTools(server, tools);
  return server;
}

async function main() {
  const server = createServer();
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch((e) => {
  console.error("Fatal:", e);
  process.exit(1);
});
```

**Step 4: Write Tools.test.ts**

```ts
import { describe, expect, test, beforeEach, afterEach } from "bun:test";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { InMemoryTransport } from "@modelcontextprotocol/sdk/inMemory.js";
import { createServer } from "./Mcp.js";
import { mkdtempSync, rmSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { Effect } from "effect";
import { SqliteClient } from "@effect/sql-sqlite-bun";
import { initSchema } from "./Db.js";
import { Config, ConfigLive } from "./Config.js";
import { GitLive } from "./Git.js";
import { BunContext } from "@effect/platform-bun";
import { rebuildIndex } from "./Indexer.js";
import { Layer } from "effect";
import * as S from "@effect/schema/Schema";
import { KisteConfigSchema } from "./Config.js";

function git(cwd: string, ...args: string[]) {
  const result = Bun.spawnSync(["git", ...args], { cwd, stdout: "pipe", stderr: "pipe" });
  if (!result.success) throw new Error(`git ${args.join(" ")} failed: ${result.stderr.toString()}`);
  return result.stdout.toString().trim();
}

describe("MCP Tools", () => {
  let repoDir: string;
  let dbPath: string;
  let client: Client;

  beforeEach(async () => {
    // Create and index a temp repo
    repoDir = mkdtempSync(join(tmpdir(), "kiste-mcp-test-"));
    dbPath = join(repoDir, ".kiste", "index.sqlite");
    Bun.spawnSync(["mkdir", "-p", join(repoDir, ".kiste")]);
    Bun.spawnSync(["mkdir", "-p", join(repoDir, "src", "auth")]);

    git(repoDir, "init");
    git(repoDir, "config", "user.email", "test@test.com");
    git(repoDir, "config", "user.name", "Test");
    writeFileSync(join(repoDir, "src", "auth", "login.ts"), "export const login = () => {};");
    git(repoDir, "add", ".");
    git(repoDir, "commit", "-m", "feat(auth): add login handler");

    // Index
    const layer = Layer.mergeAll(
      Layer.succeed(Config, S.decodeUnknownSync(KisteConfigSchema)({})),
      SqliteClient.layer({ filename: dbPath }),
      GitLive,
      BunContext.layer,
    );
    await Effect.runPromise(
      Effect.gen(function* () {
        yield* initSchema;
        yield* rebuildIndex(repoDir);
      }).pipe(Effect.provide(layer)),
    );

    // Set up MCP client
    const server = createServer();
    const [clientTransport, serverTransport] = InMemoryTransport.createLinkedPair();
    await server.connect(serverTransport);
    client = new Client({ name: "test-client", version: "1.0.0" });
    await client.connect(clientTransport);
  });

  afterEach(() => {
    rmSync(repoDir, { recursive: true, force: true });
  });

  test("kiste_list_tags returns tags", async () => {
    const result = await client.callTool({
      name: "kiste_list_tags",
      arguments: { db_path: dbPath, repo_dir: repoDir },
    });
    const data = JSON.parse((result.content as any)[0].text);
    expect(data.some((t: any) => t.tag === "auth")).toBe(true);
  });

  test("kiste_list_artifacts returns artifacts", async () => {
    const result = await client.callTool({
      name: "kiste_list_artifacts",
      arguments: { db_path: dbPath, repo_dir: repoDir },
    });
    const data = JSON.parse((result.content as any)[0].text);
    expect(data.length).toBeGreaterThan(0);
    expect(data.some((a: any) => a.path.includes("login.ts"))).toBe(true);
  });

  test("kiste_get_artifact returns content from git", async () => {
    const result = await client.callTool({
      name: "kiste_get_artifact",
      arguments: { db_path: dbPath, repo_dir: repoDir, path: "src/auth/login.ts" },
    });
    const data = JSON.parse((result.content as any)[0].text);
    expect(data.content).toContain("export const login");
    expect(data.tags).toContain("auth");
  });

  test("kiste_search finds by commit message", async () => {
    const result = await client.callTool({
      name: "kiste_search",
      arguments: { db_path: dbPath, repo_dir: repoDir, query: "login" },
    });
    const data = JSON.parse((result.content as any)[0].text);
    expect(data.length).toBeGreaterThan(0);
  });

  test("kiste_get_provenance returns commit history", async () => {
    const result = await client.callTool({
      name: "kiste_get_provenance",
      arguments: { db_path: dbPath, repo_dir: repoDir, path: "src/auth/login.ts" },
    });
    const data = JSON.parse((result.content as any)[0].text);
    expect(data.length).toBe(1);
    expect(data[0].message).toContain("feat(auth)");
  });
});
```

**Step 5: Run all tests**

```bash
bun test packages/kiste/
```

Expected: All PASS.

**Step 6: Build**

```bash
turbo build --filter=@varp/kiste
```

Expected: Both `dist/cli.js` and `dist/mcp.js` created.

**Step 7: Commit**

```bash
git add packages/kiste/src/tool-registry.ts packages/kiste/src/Tools.ts packages/kiste/src/Mcp.ts packages/kiste/src/Tools.test.ts
git commit -m "feat(kiste): add MCP server with 5 query tools"
```

---

## Task 9: End-to-End Verification

**Step 1: Index this repo**

```bash
bun run packages/kiste/dist/cli.js init
bun run packages/kiste/dist/cli.js index
bun run packages/kiste/dist/cli.js status
```

Expected: Shows commit count matching `git rev-list --count HEAD`, positive artifact count.

**Step 2: Query by tag**

```bash
bun run packages/kiste/dist/cli.js query --tags manifest
```

Expected: Returns files from `packages/core/src/manifest/`.

**Step 3: Run full check**

```bash
turbo check --filter=@varp/kiste
```

Expected: format + lint + build all pass.

**Step 4: Final commit**

```bash
git add -A
git commit -m "chore(kiste): end-to-end verification pass"
```

---

## Important Notes for the Implementing Agent

### Effect TS Skills

Use these skills when writing Effect code:
- `effect-ts:effect-core` — Effect.gen, Effect.succeed/fail, pipe patterns
- `effect-ts:requirements-management` — Context.Tag, Layer, Effect.provide
- `effect-ts:error-management` — Data.TaggedError, catchTag
- `effect-ts:schema` — @effect/schema (NOT Zod, except for MCP SDK compat)
- `effect-ts:platform` — @effect/platform Command for subprocess
- `effect-ts:testing` — testing Effect programs with bun:test
- `effect-ts:code-style` — idiomatic Effect patterns

### Code in This Plan is Approximate

The Effect and `@effect/sql-sqlite-bun` APIs may differ from what's shown. The plan provides the **logical structure** — consult the Effect TS skills and docs for exact syntax. Key areas likely to need adjustment:
- `SqliteClient.layer()` construction
- `@effect/sql` tagged template syntax (`sql\`...\``)
- `@effect/cli` Command composition
- `@effect/platform` Command for subprocess

### Build Target

Always `--target bun`. Never `--target node`. `bun:sqlite` requires it.

### Testing

Use `Effect.runPromise` directly in `bun:test` (not `@effect/vitest`). Mock services via `Layer.succeed`.
